# Pagination 개념
## 페이지
```
total list = [a0, a1, a2, a3, a4, a5, a6, a7 ... a102]

한 페이지 당 3개의 객체를 보여주려 함.

1번 페이지 - [a0, a1, a2]
2번 페이지 - [a3, a4, a5]
3번 페이지 - [a6, a7, a8]
...

```

- 1 번 페이지 0 ~ 2 객체
- 2 번 페이지 3 ~ 5 객체
- 3 번 페이지 6 ~ 8 객체
- 3 번 페이지 9 ~ 11 객체
  - 수가 나열되어 있음 (수열)
  - 규칙을 찾아야 함.
    - 현재는 등차 수열.

등차 수열이므로 등차 (3) 를 n 에 곱해나간다. (n 은 페이지 번호)
여기서 첫번째 페이지 인덱스를 맞추기 위해서는 n - 1 로서 수행 되어야 함.
- 3 * (n - 1), 이것이 시작 index 가 된다.

마지막 Index 도 마찬가지로, 3의 등차를 가진 등차 수열임. (2, 5, 8, 11 ...)
마지막 인덱스를 맞추기 위해 (3 * n) 후 -1 을 수행해준다.
- 3 * n - 1, 이것이 마지막 index 가 된다.


## 섹션
하나의 섹션에 10개의 페이지 번호를 보여준다 라고 하면,

- 1번 섹션 - [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 
- 2번 섹션 - [11, 12, 13, 14, 15, 16, 17, 18, 19, 20] 
- 3번 섹션 - [21, 22, 23, 24, 25, 26, 27, 28, 29, 30]

와 같이 지정할 수 있고, 이 또한 페이지 인덱스 처리와 동일한 로직을 가지게 되며 등차만 10 으로 변경해주면 된다.
- 시작 인덱스: 10 * (n - 1)
- 종료 인덱스: 10 * n - 1


# Pagination 2가지 방법 존재
## 1. FE 처리
```
DB 에 Data 가 많지 않은 경우 (전체 데이터가 적을 때) 에는 FE 처리가 효율적.
```

1. BE 에서 전체 객체 리스트를 받아온다.
2. FE 에서 Slicing 처리.


## 2. BE 처리
```
DB 에 Data 가 굉장히 많은 경우 (전체 데이터가 많을 때) 에는 BE 처리가 효율적.

장점: 상대적으로 로딩 속도 빠름
단점: 한 페이지 이동 시마다 계속 DB 에 Request 해야 함. (캐싱이 없다는 전제 하에)
```

1. client 로부터 현재 페이지 번호를 받아온다.
2. 해당 페이지에서 보여줄 객체 리스트만 반환.
3. 전체 객체 객수 또한 함께 반환 해주어야 함.
    - 실제 Pagination 을 보면 `< 1 2 3 4 5 6 7 8 9 10 >` 과 같이 지정되어 있는 것을 본 적 있을 것이다.
    - 위와 같이 전체 페이지가 몇개 있으며, 해당 페이지 이동을 위해 전체 객체 개수 또한 FE 에서 가지고 있어야 하기 때문.

    
# FE 처리 (Custom Hook 사용)
## Custom Hook 을 사용하는 이유?
- 메인 페이지, 검색 페이지, 게시물 페이지, My 페이지 등 모든 곳에서 활용할 수 있도록 모듈화 하기 위해.
- 근데 왜 일반 함수가 아닌 Custom Hook 을 사용하는가?
  - Pagination 은 상태를 사용하기 위해 Hook 함수를 써야 함.
  - React 의 Hook 함수 (useEffect, useState ...) 는 사용 위치가 컴포넌트 위치 / Custom Hook 내부에서만 사용 가능. (Hook 내부에서 Hook 사용 가능)
  - 그래서 일반 함수에서는 useState / useEffect 를 사용할 수 없기 때문에 Custom Hook 을 만들어 Pagination 모듈을 만드는 것에 사용한다.




# Temp Memos
```js
<input className='board-list-item-start-date'
       title={'업무 시작일'}
       type={'datetime-local'}
/>
<input className='board-list-item-end-date'
       title={'업무 종료일'}
       type={'datetime-local'}
/>
```